# -*- coding: utf-8 -*-
"""SIR with SS

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XdkuI8dn70I5tLOkuiDVsed828pui6U4
"""
"""
Created on Sept 16 2020
 
@author: emanuel
"""
import numpy as np
import pylab as plb
from pynverse import inversefunc
from scipy.integrate import quad
from scipy import interpolate
from scipy.interpolate import interp1d
 

def ecs(x,t,EK,beta,gamma,M):
    Th=x[0] #g^-1 susceptibles
    pI=x[1] 
    pS=x[2] 
    pR=x[3] #Infectadxs que no estan en cuarentena
    I=x[4]  #Infectadxs Detectadxs
    R=x[5] #Recuperadxs detectadxs
    V=x[6] #Recuperadxs no detectadxs
   
    u=0
    if pI.all()>0 and I.all()>0 and Th.all()>0 and pS.all()>0:
      dTh=(-beta*pI-u)*Th
      dpI=-beta*pI*(1-pI)-gamma*pI+pI*beta*pS*H(Th)
      dpS=pI*beta*pS*(1-H(Th))+(-H(Th)+1)*pS*u
      dpR=gamma*pI+beta*pR*pI
      dI=beta*pI*Th*gprima(Th)-(gamma)*I
      dR=gamma*I
      dV=u*Th*gprima(Th)
      return np.array([dTh,dpI,dpS,dpR,dI,dR,dV])
    else:
      return np.zeros(7)

 
def int_rk4(f,x,dt,t,EK,beta,gamma,M):
    k_1 = f(x,t,EK,beta,gamma,M)
    k_2 = f(x+dt*0.5*k_1,t,EK,beta,gamma,M)
    k_3 = f(x+dt*0.5*k_2,t,EK,beta,gamma,M)
    k_4 = f(x+dt*k_3,t,EK,beta,gamma,M)
    y=x + dt*(k_1/6 + k_2/3 + k_3/3 + k_4/6)
    return y
 
def integra(T,dt,EK,beta,gamma,M):
    tiempo_modelo=np.arange(0,T,dt)
    sir=np.zeros([7,len(tiempo_modelo)])

    epsilon=0.01
    sir[0,0]=invg(1-epsilon)
    sir[1,0]=epsilon/(1-epsilon)
    sir[2,0]=(1-2*epsilon)/(1-epsilon)
    sir[3,0]=0
    sir[4,0]=epsilon
 
    R2t=np.zeros(int(T/dt)-1)
    for i in range(len(tiempo_modelo)-1):
      sir[:,i+1]=int_rk4(ecs,sir[:,i],dt,tiempo_modelo[i],EK,beta,gamma,M)
      R2t[i]=1
    return np.array([sir,R2t])

lambd=8
g = lambda x: np.exp(lambd*(x-1))
gprima = lambda x: lambd*np.exp(lambd*(x-1));
gdosprima = lambda x: lambd*lambd*np.exp(lambd*(x-1))
gtresprima = lambda x: (lambd**3)*np.exp(lambd*(x-1))

H = lambda x: x*gdosprima(x)/gprima(x)

invg=inversefunc(g)

#M=10000
#EK=0.9*0+0.1*50

#gamma=1
#beta=3



def sir_num(T,dt,EK,ga,b,lamb,pob):
    beta=b
    gamma=ga
    lambd=lamb
    M=pob
    sirss=integra(T,dt,EK,beta,gamma,M)
    th1,pI1,pS1,pR1,I,R,V=sirss[0]
    S=g(th1)
    
    return np.array([S,I,R])



